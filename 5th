import cv2
import mediapipe as mp
import RPi.GPIO as GPIO
from time import sleep, time

# ----------------------------
# Motor Setup
# ----------------------------
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# ëª¨í„° í•€ (ìƒÂ·í•˜ë¶€ í†µí•©)
Ena, In1, In2 = 2, 3, 4
GPIO.setup(Ena, GPIO.OUT)
GPIO.setup(In1, GPIO.OUT)
GPIO.setup(In2, GPIO.OUT)

pwm = GPIO.PWM(Ena, 100)  # 100Hz
pwm.start(0)

# ----------------------------
# Limit Switch Setup
# ----------------------------
SWITCH_BOTTOM = 5  # í•˜ë‹¨
SWITCH_TOP = 6     # ìƒë‹¨

# 3.3V â†’ GPIO â†’ GND ë°©ì‹ì´ë¼ PUD_UP ì‚¬ìš©
GPIO.setup(SWITCH_BOTTOM, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SWITCH_TOP, GPIO.IN, pull_up_down=GPIO.PUD_UP)

def is_bottom_pressed():
    return GPIO.input(SWITCH_BOTTOM) == GPIO.LOW

def is_top_pressed():
    return GPIO.input(SWITCH_TOP) == GPIO.LOW

# ----------------------------
# Motor Control
# ----------------------------
def motor_forward(speed=50, duration=1):
    """ëª¨í„° ì˜¬ë¦¬ê¸° (UP)"""
    if is_top_pressed():
        print("ğŸš« Top limit reached â€” cannot move upward.")
        motor_stop()
        return
    GPIO.output(In1, GPIO.LOW)
    GPIO.output(In2, GPIO.HIGH)
    pwm.ChangeDutyCycle(speed)
    start_time = time()
    while time() - start_time < duration:
        if is_top_pressed():
            print("ğŸ§± Top limit reached during motion â€” stopping.")
            break
        sleep(0.01)
    motor_stop()

def motor_backward(speed=50, duration=1):
    """ëª¨í„° ë‚´ë¦¬ê¸° (DOWN)"""
    if is_bottom_pressed():
        print("ğŸš« Bottom limit reached â€” cannot move downward.")
        motor_stop()
        return
    GPIO.output(In1, GPIO.HIGH)
    GPIO.output(In2, GPIO.LOW)
    pwm.ChangeDutyCycle(speed)
    start_time = time()
    while time() - start_time < duration:
        if is_bottom_pressed():
            print("ğŸ§± Bottom limit reached during motion â€” stopping.")
            break
        sleep(0.01)
    motor_stop()

def motor_stop():
    GPIO.output(In1, GPIO.LOW)
    GPIO.output(In2, GPIO.LOW)
    pwm.ChangeDutyCycle(0)

# ----------------------------
# Pose Detection Setup
# ----------------------------
mp_pose = mp.solutions.pose
pose = mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5)
cap = cv2.VideoCapture(0)

# ----------------------------
# Parameters
# ----------------------------
baseline_distance = None
THRESHOLD_RATIO = 0.8
RECOVER_RATIO = 0.95
BAD_STABLE_THRESHOLD = 5
GOOD_STABLE_THRESHOLD = 15

MAX_MOVES = 5
current_position = 0

MOTOR_STEP_DURATION = 1.0
MOTOR_SPEED = 50

bad_count = 0
good_count = 0
last_move_time = 0
MIN_INTERVAL_BETWEEN_MOVES = 0.8

print("ğŸ“· Initializing system... Moving monitor arm to baseline position.")

# ----------------------------
# Step 1: Auto Calibration using Bottom Switch
# ----------------------------
print("ğŸ”§ Moving down to find bottom limit switch...")
while not is_bottom_pressed():
    print(f"[Switch Status] Bottom: {'Pressed' if is_bottom_pressed() else 'Released'} | Top: {'Pressed' if is_top_pressed() else 'Released'}")
    motor_backward(speed=40, duration=0.1)
motor_stop()
print("âœ… Bottom switch detected â€” baseline position set.")
current_position = 0
baseline_distance = None
sleep(1)
print("ğŸ“· Starting camera feed. Sit upright to calibrate posture baseline.")

# ----------------------------
# Step 2: Pose Detection Loop
# ----------------------------
try:
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            print("âŒ Unable to read camera frame.")
            break

        frame = cv2.flip(frame, 1)
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(rgb_frame)

        # --- ì‹¤ì‹œê°„ ìŠ¤ìœ„ì¹˜ ìƒíƒœ ì¶œë ¥ ---
        print(f"[Switch Status] Bottom: {'ğŸ”´ Pressed' if is_bottom_pressed() else 'âšª Released'} | Top: {'ğŸ”´ Pressed' if is_top_pressed() else 'âšª Released'}")

        if results.pose_landmarks:
            landmarks = results.pose_landmarks.landmark
            nose = landmarks[mp_pose.PoseLandmark.NOSE]
            left_shoulder = landmarks[mp_pose.PoseLandmark.LEFT_SHOULDER]
            right_shoulder = landmarks[mp_pose.PoseLandmark.RIGHT_SHOULDER]

            shoulder_center_y = (left_shoulder.y + right_shoulder.y) / 2.0
            distance = shoulder_center_y - nose.y

            # ìµœì´ˆ baseline ì¸ì‹
            if baseline_distance is None:
                baseline_distance = distance
                print("âœ… Posture baseline saved! Maintain good posture.")
                continue

            ratio = distance / baseline_distance if baseline_distance != 0 else 1.0

            # --- BAD posture (forward head)
            if ratio < THRESHOLD_RATIO:
                bad_count += 1
                good_count = 0
                print(f"âš ï¸ Forward head detected ({bad_count}/{BAD_STABLE_THRESHOLD})")
                if bad_count >= BAD_STABLE_THRESHOLD:
                    now = time()
                    if current_position < MAX_MOVES and (now - last_move_time) > MIN_INTERVAL_BETWEEN_MOVES:
                        if not is_top_pressed():
                            print(f"ğŸŸ¢ Moving monitor arm UP: {current_position} â†’ {current_position + 1}")
                            motor_forward(speed=MOTOR_SPEED, duration=MOTOR_STEP_DURATION)
                            current_position += 1
                            last_move_time = time()
                        else:
                            print("ğŸ”´ Top limit switch active â€” cannot move up.")
                    bad_count = 0

            # --- GOOD posture (recovered)
            elif ratio >= RECOVER_RATIO:
                good_count += 1
                bad_count = 0
                print(f"ğŸ˜Š Good posture maintained ({good_count}/{GOOD_STABLE_THRESHOLD})")
                if good_count >= GOOD_STABLE_THRESHOLD:
                    now = time()
                    if current_position > 0 and (now - last_move_time) > MIN_INTERVAL_BETWEEN_MOVES:
                        if not is_bottom_pressed():
                            print(f"ğŸ”µ Moving monitor arm DOWN: {current_position} â†’ {current_position - 1}")
                            motor_backward(speed=MOTOR_SPEED, duration=MOTOR_STEP_DURATION)
                            current_position -= 1
                            last_move_time = time()
                        else:
                            print("â„¹ï¸ Bottom switch active â€” cannot move further down.")
                    good_count = 0
            else:
                bad_count = 0
                good_count = 0
                print("ğŸŸ¡ Neutral posture (no movement)")
        else:
            bad_count = 0
            good_count = 0
            print("â— No person detected â€” waiting...")

        sleep(0.2)

except KeyboardInterrupt:
    print("ğŸ›‘ Interrupted by user.")

finally:
    cap.release()
    motor_stop()
    pwm.stop()
    GPIO.cleanup()
    print("Program terminated safely.")

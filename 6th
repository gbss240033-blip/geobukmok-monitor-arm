import cv2
import mediapipe as mp
import RPi.GPIO as GPIO
from time import sleep, time

# ----------------------------
# Motor Setup
# ----------------------------
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# --- Motor 1 (Upper Arm)
Ena1, In1A, In1B = 2, 3, 4
GPIO.setup(Ena1, GPIO.OUT)
GPIO.setup(In1A, GPIO.OUT)
GPIO.setup(In1B, GPIO.OUT)
pwm1 = GPIO.PWM(Ena1, 100)
pwm1.start(0)

# --- Motor 2 (Lower Arm)
EnB, In2A, In2B = 17, 22, 27  # In2A, In2B ÌïÄ ÌôïÏù∏ ÌïÑÏöî
GPIO.setup(EnB, GPIO.OUT)
GPIO.setup(In2A, GPIO.OUT)
GPIO.setup(In2B, GPIO.OUT)
pwm2 = GPIO.PWM(EnB, 100)
pwm2.start(0)

# ----------------------------
# Limit Switch Setup
# ----------------------------
SWITCH_BOTTOM = 5  # ÌïòÎã®
SWITCH_TOP = 6     # ÏÉÅÎã®
GPIO.setup(SWITCH_BOTTOM, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SWITCH_TOP, GPIO.IN, pull_up_down=GPIO.PUD_UP)

def is_bottom_pressed():
    return GPIO.input(SWITCH_BOTTOM) == GPIO.LOW

def is_top_pressed():
    return GPIO.input(SWITCH_TOP) == GPIO.LOW

# ----------------------------
# Motor Control
# ----------------------------
def motor_forward(motor='upper', speed=50, duration=1):
    """Î™®ÌÑ∞ Ïò¨Î¶¨Í∏∞ (UP)"""
    if is_top_pressed():
        print("üö´ Top limit reached ‚Äî cannot move upward.")
        motor_stop(motor)
        return
    if motor == 'upper':
        GPIO.output(In1A, GPIO.LOW)
        GPIO.output(In1B, GPIO.HIGH)
        pwm1.ChangeDutyCycle(speed)
        start_time = time()
        while time() - start_time < duration:
            if is_top_pressed():
                print("üß± Upper motor reached top limit ‚Äî stopping.")
                break
            sleep(0.01)
        motor_stop('upper')
    else:
        GPIO.output(In2A, GPIO.LOW)
        GPIO.output(In2B, GPIO.HIGH)
        pwm2.ChangeDutyCycle(speed)
        start_time = time()
        while time() - start_time < duration:
            if is_top_pressed():
                print("üß± Lower motor reached top limit ‚Äî stopping.")
                break
            sleep(0.01)
        motor_stop('lower')

def motor_backward(motor='upper', speed=50, duration=1):
    """Î™®ÌÑ∞ ÎÇ¥Î¶¨Í∏∞ (DOWN)"""
    if is_bottom_pressed():
        print("üö´ Bottom limit reached ‚Äî cannot move downward.")
        motor_stop(motor)
        return
    if motor == 'upper':
        GPIO.output(In1A, GPIO.HIGH)
        GPIO.output(In1B, GPIO.LOW)
        pwm1.ChangeDutyCycle(speed)
        start_time = time()
        while time() - start_time < duration:
            if is_bottom_pressed():
                print("üß± Upper motor reached bottom limit ‚Äî stopping.")
                break
            sleep(0.01)
        motor_stop('upper')
    else:
        GPIO.output(In2A, GPIO.HIGH)
        GPIO.output(In2B, GPIO.LOW)
        pwm2.ChangeDutyCycle(speed)
        start_time = time()
        while time() - start_time < duration:
            if is_bottom_pressed():
                print("üß± Lower motor reached bottom limit ‚Äî stopping.")
                break
            sleep(0.01)
        motor_stop('lower')

def motor_stop(motor='both'):
    if motor in ['upper', 'both']:
        GPIO.output(In1A, GPIO.LOW)
        GPIO.output(In1B, GPIO.LOW)
        pwm1.ChangeDutyCycle(0)
    if motor in ['lower', 'both']:
        GPIO.output(In2A, GPIO.LOW)
        GPIO.output(In2B, GPIO.LOW)
        pwm2.ChangeDutyCycle(0)

# ----------------------------
# Pose Detection Setup
# ----------------------------
mp_pose = mp.solutions.pose
pose = mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5)
cap = cv2.VideoCapture(0)

# ----------------------------
# Parameters
# ----------------------------
baseline_distance = None
THRESHOLD_RATIO = 0.8
RECOVER_RATIO = 0.95
BAD_STABLE_THRESHOLD = 5
GOOD_STABLE_THRESHOLD = 15

MAX_MOVES = 5
current_position_upper = 0
current_position_lower = 0

MOTOR_STEP_DURATION = 1.0
MOTOR_SPEED = 50

bad_count = 0
good_count = 0
last_move_time = 0
MIN_INTERVAL_BETWEEN_MOVES = 0.8
MAX_UP_DURATION = 2.0
MAX_DOWN_DURATION = 2.0

# ----------------------------
# Step 0: Initialization
# ----------------------------
print("üì∑ Initializing system... Checking switch states.")

# --- Upper Motor Ï¥àÍ∏∞Ìôî
if is_bottom_pressed():
    print("üîº Upper motor bottom pressed at start ‚Äî moving UP to release.")
    motor_forward('upper', speed=MOTOR_SPEED, duration=MAX_UP_DURATION)
sleep(0.2)
print("üîΩ Upper motor moving DOWN to baseline.")
motor_backward('upper', speed=MOTOR_SPEED, duration=MAX_DOWN_DURATION)

# --- Lower Motor Ï¥àÍ∏∞Ìôî
if is_bottom_pressed():
    print("üîº Lower motor bottom pressed at start ‚Äî moving UP to release.")
    motor_forward('lower', speed=MOTOR_SPEED, duration=MAX_UP_DURATION)
sleep(0.2)
print("üîΩ Lower motor moving DOWN to baseline.")
motor_backward('lower', speed=MOTOR_SPEED, duration=MAX_DOWN_DURATION)

motor_stop('both')
baseline_distance = None
sleep(1)
print("üì∑ Camera feed starting. Sit upright to calibrate baseline posture.")

# Ïù¥ÌõÑ ÏûêÏÑ∏ Í∏∞Î∞ò Î™®ÌÑ∞ Ï†úÏñ¥Îäî Í∏∞Ï°¥ Î°úÏßÅÏùÑ motor_forward/ backward('upper' or 'lower') ÌòïÌÉúÎ°ú Ìò∏Ï∂ú Í∞ÄÎä•
# Ïòà: motor_forward('upper', speed=50, duration=1.0)

# ----------------------------
# Í∏∞Ï°¥ ÏûêÏÑ∏ Í∏∞Î∞ò Ï†úÏñ¥ Î£®ÌîÑÎäî ÌïÑÏöîÏãú Í∑∏ÎåÄÎ°ú Ï†ÅÏö©
# ----------------------------
try:
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            print("‚ùå Unable to read camera frame.")
            break
        frame = cv2.flip(frame, 1)
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(rgb_frame)

        print(f"[Switch Status] Bottom: {'üî¥ Pressed' if is_bottom_pressed() else '‚ö™ Released'} | Top: {'üî¥ Pressed' if is_top_pressed() else '‚ö™ Released'}")

        if results.pose_landmarks:
            landmarks = results.pose_landmarks.landmark
            nose = landmarks[mp_pose.PoseLandmark.NOSE]
            left_shoulder = landmarks[mp_pose.PoseLandmark.LEFT_SHOULDER]
            right_shoulder = landmarks[mp_pose.PoseLandmark.RIGHT_SHOULDER]

            shoulder_center_y = (left_shoulder.y + right_shoulder.y) / 2.0
            distance = shoulder_center_y - nose.y

            if baseline_distance is None:
                baseline_distance = distance
                print("‚úÖ Posture baseline saved! Maintain good posture.")
                continue

            ratio = distance / baseline_distance if baseline_distance != 0 else 1.0

            # BAD posture
            if ratio < THRESHOLD_RATIO:
                bad_count += 1
                good_count = 0
                if bad_count >= BAD_STABLE_THRESHOLD:
                    now = time()
                    if current_position_upper < MAX_MOVES:
                        motor_forward('upper', MOTOR_SPEED, MOTOR_STEP_DURATION)
                        current_position_upper += 1
                        last_move_time = now
                    if current_position_lower < MAX_MOVES:
                        motor_forward('lower', MOTOR_SPEED, MOTOR_STEP_DURATION)
                        current_position_lower += 1
                        last_move_time = now
                    bad_count = 0

            # GOOD posture
            elif ratio >= RECOVER_RATIO:
                good_count += 1
                bad_count = 0
                if good_count >= GOOD_STABLE_THRESHOLD:
                    now = time()
                    if current_position_upper > 0:
                        motor_backward('upper', MOTOR_SPEED, MOTOR_STEP_DURATION)
                        current_position_upper -= 1
                        last_move_time = now
                    if current_position_lower > 0:
                        motor_backward('lower', MOTOR_SPEED, MOTOR_STEP_DURATION)
                        current_position_lower -= 1
                        last_move_time = now
                    good_count = 0
            else:
                bad_count = 0
                good_count = 0

        else:
            bad_count = 0
            good_count = 0

        sleep(0.2)

except KeyboardInterrupt:
    print("üõë Interrupted by user.")

finally:
   

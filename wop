import cv2
import mediapipe as mp
import RPi.GPIO as GPIO
from time import sleep, time

# ----------------------------
# Motor Setup
# ----------------------------
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# Upper Motor
Ena1, In1A, In1B = 2, 3, 4
GPIO.setup(Ena1, GPIO.OUT)
GPIO.setup(In1A, GPIO.OUT)
GPIO.setup(In1B, GPIO.OUT)
pwm1 = GPIO.PWM(Ena1, 100)
pwm1.start(0)

# Lower Motor
EnB, In2A, In2B = 17, 22, 27
GPIO.setup(EnB, GPIO.OUT)
GPIO.setup(In2A, GPIO.OUT)
GPIO.setup(In2B, GPIO.OUT)
pwm2 = GPIO.PWM(EnB, 100)
pwm2.start(0)

# ----------------------------
# Limit Switch Setup
# ----------------------------
SWITCH_BOTTOM = 5
SWITCH_TOP = 6
GPIO.setup(SWITCH_BOTTOM, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SWITCH_TOP, GPIO.IN, pull_up_down=GPIO.PUD_UP)

def is_bottom_pressed():
    return GPIO.input(SWITCH_BOTTOM) == GPIO.LOW

def is_top_pressed():
    return GPIO.input(SWITCH_TOP) == GPIO.LOW

# ----------------------------
# Motor Control
# ----------------------------
def motor_set_state(motor='upper', state='stop', speed=50):
    if motor == 'upper':
        if state == 'up':
            GPIO.output(In1A, GPIO.LOW)
            GPIO.output(In1B, GPIO.HIGH)
            pwm1.ChangeDutyCycle(speed)
        elif state == 'down':
            GPIO.output(In1A, GPIO.HIGH)
            GPIO.output(In1B, GPIO.LOW)
            pwm1.ChangeDutyCycle(speed)
        else:
            GPIO.output(In1A, GPIO.LOW)
            GPIO.output(In1B, GPIO.LOW)
            pwm1.ChangeDutyCycle(0)
    else:
        if state == 'up':
            GPIO.output(In2A, GPIO.LOW)
            GPIO.output(In2B, GPIO.HIGH)
            pwm2.ChangeDutyCycle(speed)
        elif state == 'down':
            GPIO.output(In2A, GPIO.HIGH)
            GPIO.output(In2B, GPIO.LOW)
            pwm2.ChangeDutyCycle(speed)
        else:
            GPIO.output(In2A, GPIO.LOW)
            GPIO.output(In2B, GPIO.LOW)
            pwm2.ChangeDutyCycle(0)

# ----------------------------
# Pose Detection Setup
# ----------------------------
mp_pose = mp.solutions.pose
pose = mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5)
cap = cv2.VideoCapture(0)

# ----------------------------
# Parameters
# ----------------------------
baseline_distance = None
RECOVER_RATIO = 0.95
MOTOR_SPEED = 50
LOOP_DELAY = 0.2

# ìµœëŒ€ ë„ë‹¬ ì‹œê°„ì„ ê¸°ì¤€ìœ¼ë¡œ ìµœëŒ€ ì´ë™ ê±°ë¦¬ ì œí•œ
MAX_UP_TIME = 5.0  # ì´ˆ ë‹¨ìœ„, ëª¨í„° ìµœëŒ€ ì˜¬ë¼ê°ˆ ì‹œê°„
MAX_DOWN_TIME = 5.0  # ëª¨í„° ìµœëŒ€ ë‚´ë ¤ê°ˆ ì‹œê°„
upper_up_time = 0.0
lower_up_time = 0.0

motor_state_upper = 'stop'
motor_state_lower = 'stop'

# ----------------------------
# Step 0: Initialization
# ----------------------------
print("ğŸ“· Initializing system... Checking switch states.")

# Upper Motor ì´ˆê¸°í™”
if is_bottom_pressed():
    print("ğŸ”¼ Upper motor bottom pressed â€” moving UP to release")
    motor_set_state('upper', 'up', MOTOR_SPEED)
    sleep(2)
motor_set_state('upper', 'down', MOTOR_SPEED)
sleep(2)
motor_set_state('upper', 'stop')

# Lower Motor ì´ˆê¸°í™”
if is_bottom_pressed():
    print("ğŸ”¼ Lower motor bottom pressed â€” moving UP to release")
    motor_set_state('lower', 'up', MOTOR_SPEED)
    sleep(2)
motor_set_state('lower', 'down', MOTOR_SPEED)
sleep(2)
motor_set_state('lower', 'stop')

print("ğŸ“· Camera feed starting. Sit upright to calibrate baseline posture.")

# ----------------------------
# Posture-based Motor Control Loop
# ----------------------------
try:
    switch_status_printed = False
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            print("âŒ Unable to read camera frame.")
            break
        frame = cv2.flip(frame, 1)
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(rgb_frame)

        # Switch status ì¶œë ¥: ë‘˜ ë‹¤ pressed ìƒíƒœê°€ ë  ë•Œê¹Œì§€ë§Œ
        if not switch_status_printed:
            print(f"[Switch Status] Bottom: {'ğŸ”´ Pressed' if is_bottom_pressed() else 'âšª Released'} | Top: {'ğŸ”´ Pressed' if is_top_pressed() else 'âšª Released'}")
            if is_bottom_pressed() and is_top_pressed():
                switch_status_printed = True

        if results.pose_landmarks:
            landmarks = results.pose_landmarks.landmark
            nose = landmarks[mp_pose.PoseLandmark.NOSE]
            left_shoulder = landmarks[mp_pose.PoseLandmark.LEFT_SHOULDER]
            right_shoulder = landmarks[mp_pose.PoseLandmark.RIGHT_SHOULDER]

            shoulder_center_y = (left_shoulder.y + right_shoulder.y) / 2.0
            distance = shoulder_center_y - nose.y

            if baseline_distance is None:
                baseline_distance = distance
                print("âœ… Posture baseline saved! Maintain good posture.")
                continue

            ratio = distance / baseline_distance if baseline_distance != 0 else 1.0

            # ê±°ë¶ëª© ë³´ì •: ratio < 0.95 -> UP, >=0.95 -> STOP
            if ratio < RECOVER_RATIO:
                # Upper motor: ìµœëŒ€ ì‹œê°„ ì œí•œ ì²´í¬
                if upper_up_time < MAX_UP_TIME and not is_top_pressed():
                    motor_state_upper = 'up'
                    upper_up_time += LOOP_DELAY
                else:
                    motor_state_upper = 'stop'

                # Lower motor: ìµœëŒ€ ì‹œê°„ ì œí•œ ì²´í¬
                if lower_up_time < MAX_UP_TIME and not is_top_pressed():
                    motor_state_lower = 'up'
                    lower_up_time += LOOP_DELAY
                else:
                    motor_state_lower = 'stop'
            else:
                motor_state_upper = 'stop'
                motor_state_lower = 'stop'

        # ëª¨í„° ìƒíƒœ ì ìš©
        motor_set_state('upper', motor_state_upper, MOTOR_SPEED)
        motor_set_state('lower', motor_state_lower, MOTOR_SPEED)

        sleep(LOOP_DELAY)

except KeyboardInterrupt:
    print("ğŸ›‘ Interrupted by user.")

finally:
    cap.release()
    motor_set_state('upper', 'stop')
    motor_set_state('lower', 'stop')
    pwm1.stop()
    pwm2.stop()
    GPIO.cleanup()
    print("Program terminated safely.")


import cv2
import mediapipe as mp
import RPi.GPIO as GPIO
from time import sleep, time

# ========================================
# GPIO & Motor Setup
# ========================================
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# --- Upper Motor ---
Ena1, In1A, In1B = 2, 3, 4
GPIO.setup(Ena1, GPIO.OUT)
GPIO.setup(In1A, GPIO.OUT)
GPIO.setup(In1B, GPIO.OUT)
pwm1 = GPIO.PWM(Ena1, 100)
pwm1.start(0)

# --- Lower Motor ---
EnB, In2A, In2B = 17, 22, 27
GPIO.setup(EnB, GPIO.OUT)
GPIO.setup(In2A, GPIO.OUT)
GPIO.setup(In2B, GPIO.OUT)
pwm2 = GPIO.PWM(EnB, 100)
pwm2.start(0)

# --- Limit Switches ---
SWITCH_BOTTOM = 5  # bottom switch
SWITCH_TOP = 6     # top switch
GPIO.setup(SWITCH_BOTTOM, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SWITCH_TOP, GPIO.IN, pull_up_down=GPIO.PUD_UP)

def is_bottom_pressed():
    return GPIO.input(SWITCH_BOTTOM) == GPIO.LOW

def is_top_pressed():
    return GPIO.input(SWITCH_TOP) == GPIO.LOW

# ========================================
# Motor Control Functions
# ========================================
def motor_up(speed=50):
    """Move both motors upward"""
    if is_top_pressed():
        motor_stop()
        print("üß± Top limit reached - stop UP motion.")
        return
    GPIO.output(In1A, GPIO.LOW)
    GPIO.output(In1B, GPIO.HIGH)
    pwm1.ChangeDutyCycle(speed)
    GPIO.output(In2A, GPIO.LOW)
    GPIO.output(In2B, GPIO.HIGH)
    pwm2.ChangeDutyCycle(speed)

def motor_down(speed=50):
    """Move both motors downward"""
    if is_bottom_pressed():
        motor_stop()
        print("üß± Bottom limit reached - stop DOWN motion.")
        return
    GPIO.output(In1A, GPIO.HIGH)
    GPIO.output(In1B, GPIO.LOW)
    pwm1.ChangeDutyCycle(speed)
    GPIO.output(In2A, GPIO.HIGH)
    GPIO.output(In2B, GPIO.LOW)
    pwm2.ChangeDutyCycle(speed)

def motor_stop():
    """Stop both motors"""
    GPIO.output(In1A, GPIO.LOW)
    GPIO.output(In1B, GPIO.LOW)
    GPIO.output(In2A, GPIO.LOW)
    GPIO.output(In2B, GPIO.LOW)
    pwm1.ChangeDutyCycle(0)
    pwm2.ChangeDutyCycle(0)

# ========================================
# Pose Detection Setup
# ========================================
mp_pose = mp.solutions.pose
pose = mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5)
cap = cv2.VideoCapture(0)

# ========================================
# Parameters
# ========================================
baseline_distance = None
THRESHOLD_RATIO = 0.8
RECOVER_RATIO = 0.95
MOTOR_SPEED = 50
MAX_UP_TIME = 3.0  # safety limit for upward movement (sec)

# ========================================
# Step 1: FORCED Initialization
# ========================================
print("üì∑ Initializing system...")
print("üîß Phase 1: Moving UP to clear any existing bottom position.")

# Î¨¥Ï°∞Í±¥ ÏúÑÎ°ú 2Ï¥àÍ∞Ñ Ïù¥Îèô (Ïä§ÏúÑÏπò ÏÉÅÌÉú Î¨¥Í¥Ä)
start_time = time()
while time() - start_time < 2.0:
    if is_top_pressed():
        print("üß± Top switch detected during init - stopping.")
        break
    motor_up(MOTOR_SPEED)
    sleep(0.1)

motor_stop()
print("‚úÖ Initial UP movement complete.")
sleep(0.5)

print("üîß Phase 2: Moving DOWN to find bottom switch.")

# Ïù¥Ï†ú ÌïòÍ∞ïÌïòÏó¨ ÌïòÎã® Ïä§ÏúÑÏπò Ï∞æÍ∏∞
init_start = time()
while not is_bottom_pressed():
    if time() - init_start > 10.0:  # 10Ï¥à ÌÉÄÏûÑÏïÑÏõÉ
        print("‚ö†Ô∏è Bottom switch not found in 10 seconds. Check hardware!")
        motor_stop()
        raise RuntimeError("Initialization failed - bottom switch not detected")
    
    motor_down(MOTOR_SPEED)
    sleep(0.05)

motor_stop()
print("‚úÖ Bottom position found. Motors at starting position.")
sleep(1)

# ========================================
# Step 2: Baseline Posture Capture with Countdown
# ========================================
print("\n" + "="*50)
print("üì∏ BASELINE CALIBRATION")
print("="*50)
print("üë§ Please sit in CORRECT, UPRIGHT posture.")
print("üìè Keep your back straight and head up.")
print("")

# 3Ï¥à Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
for i in range(3, 0, -1):
    print(f"‚è±Ô∏è  Capturing baseline in {i} seconds...")
    sleep(1)

print("üì∏ Capturing NOW...")

# Baseline Ï∫°Ï≤ò (ÏµúÎåÄ 5Ï¥à ÏãúÎèÑ)
baseline_captured = False
capture_start = time()

while not baseline_captured:
    if time() - capture_start > 5.0:
        print("‚ùå Failed to detect pose. Please ensure you're visible to camera.")
        cap.release()
        motor_stop()
        pwm1.stop()
        pwm2.stop()
        GPIO.cleanup()
        raise RuntimeError("Baseline capture failed - no pose detected")
    
    ret, frame = cap.read()
    if not ret:
        print("‚ùå Camera error.")
        sleep(0.1)
        continue

    frame = cv2.flip(frame, 1)
    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = pose.process(rgb)

    if results.pose_landmarks:
        lm = results.pose_landmarks.landmark
        nose = lm[mp_pose.PoseLandmark.NOSE]
        left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
        right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]
        shoulder_center_y = (left_shoulder.y + right_shoulder.y) / 2.0
        distance = shoulder_center_y - nose.y
        
        if distance > 0:  # Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
            baseline_distance = distance
            baseline_captured = True
            print(f"‚úÖ Baseline captured! (distance: {baseline_distance:.4f})")
            print("üéØ Monitoring started. Keep good posture!")
            sleep(1)
        else:
            print("‚ö†Ô∏è Invalid pose detected, retrying...")
            sleep(0.1)

# ========================================
# Step 3: Continuous Monitoring & Correction
# ========================================
print("\n" + "="*50)
print("üîç ACTIVE POSTURE MONITORING")
print("="*50)

try:
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            print("‚ùå Camera error.")
            break

        frame = cv2.flip(frame, 1)
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(rgb)

        # If landmarks disappear ‚Üí stop motors safely
        if not results.pose_landmarks:
            print("‚ö†Ô∏è Pose lost. Stopping motors.")
            motor_stop()
            sleep(0.2)
            continue

        lm = results.pose_landmarks.landmark
        nose = lm[mp_pose.PoseLandmark.NOSE]
        left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
        right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]
        shoulder_center_y = (left_shoulder.y + right_shoulder.y) / 2.0
        distance = shoulder_center_y - nose.y

        ratio = distance / baseline_distance if baseline_distance else 1.0
        print(f"üìè ratio = {ratio:.2f}", end='')

        # Turtle Neck Detected
        if ratio < THRESHOLD_RATIO:
            print(" ‚Üí üê¢ Turtle neck! Correcting...")
            correction_start = time()
            
            while ratio < THRESHOLD_RATIO:
                # Safety checks
                if is_top_pressed():
                    print("\nüß± Top switch pressed - stopping.")
                    motor_stop()
                    break
                
                if time() - correction_start > MAX_UP_TIME:
                    print(f"\n‚è∞ Max correction time ({MAX_UP_TIME}s) reached - stopping.")
                    motor_stop()
                    break

                motor_up(MOTOR_SPEED)
                sleep(0.1)

                # Update ratio dynamically
                ret, frame = cap.read()
                if not ret:
                    break
                    
                frame = cv2.flip(frame, 1)
                rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                results = pose.process(rgb)
                
                if not results.pose_landmarks:
                    print("\n‚ö†Ô∏è Pose lost during correction - stopping.")
                    motor_stop()
                    break
                    
                lm = results.pose_landmarks.landmark
                nose = lm[mp_pose.PoseLandmark.NOSE]
                left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
                right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]
                shoulder_center_y = (left_shoulder.y + right_shoulder.y) / 2.0
                distance = shoulder_center_y - nose.y
                ratio = distance / baseline_distance if baseline_distance else 1.0
                print(f"üìè ratio = {ratio:.2f} (correcting...)", end='\r')

            motor_stop()
            print("\n‚úÖ Posture corrected or limit reached.")

        else:
            print(" ‚Üí ‚úÖ Good posture")
            motor_stop()

        sleep(0.2)

except KeyboardInterrupt:
    print("\nüõë Interrupted by user.")

finally:
    cap.release()
    motor_stop()
    pwm1.stop()
    pwm2.stop()
    GPIO.cleanup()
    print("‚úÖ Program terminated safely.")

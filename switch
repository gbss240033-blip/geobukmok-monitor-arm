import cv2
import mediapipe as mp
import RPi.GPIO as GPIO
from time import sleep, time
import math

# ========================================
# GPIO Setup
# ========================================
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# --- Upper Motor ---
Ena1, In1A, In1B = 2, 3, 4
GPIO.setup(Ena1, GPIO.OUT)
GPIO.setup(In1A, GPIO.OUT)
GPIO.setup(In1B, GPIO.OUT)
pwm1 = GPIO.PWM(Ena1, 100)
pwm1.start(0)

# --- Lower Motor ---
EnB, In2A, In2B = 17, 22, 27
GPIO.setup(EnB, GPIO.OUT)
GPIO.setup(In2A, GPIO.OUT)
GPIO.setup(In2B, GPIO.OUT)
pwm2 = GPIO.PWM(EnB, 100)
pwm2.start(0)

# --- Limit Switches ---
SWITCH_UPPER = 5
SWITCH_LOWER = 6
GPIO.setup(SWITCH_UPPER, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SWITCH_LOWER, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# ========================================
# Switch Check Functions (with debounce)
# ========================================
def is_upper_switch_pressed():
    sleep(0.02)  # debounce
    return GPIO.input(SWITCH_UPPER) == GPIO.LOW

def is_lower_switch_pressed():
    sleep(0.02)
    return GPIO.input(SWITCH_LOWER) == GPIO.LOW

# ========================================
# Motor Control
# ========================================
def upper_motor_up(speed=50):
    GPIO.output(In1A, GPIO.LOW)
    GPIO.output(In1B, GPIO.HIGH)
    pwm1.ChangeDutyCycle(speed)

def upper_motor_down(speed=50):
    GPIO.output(In1A, GPIO.HIGH)
    GPIO.output(In1B, GPIO.LOW)
    pwm1.ChangeDutyCycle(speed)

def upper_motor_stop():
    GPIO.output(In1A, GPIO.LOW)
    GPIO.output(In1B, GPIO.LOW)
    pwm1.ChangeDutyCycle(0)

def lower_motor_up(speed=50):
    GPIO.output(In2A, GPIO.LOW)
    GPIO.output(In2B, GPIO.HIGH)
    pwm2.ChangeDutyCycle(speed)

def lower_motor_down(speed=50):
    GPIO.output(In2A, GPIO.HIGH)
    GPIO.output(In2B, GPIO.LOW)
    pwm2.ChangeDutyCycle(speed)

def lower_motor_stop():
    GPIO.output(In2A, GPIO.LOW)
    GPIO.output(In2B, GPIO.LOW)
    pwm2.ChangeDutyCycle(0)

def all_stop():
    upper_motor_stop()
    lower_motor_stop()

# ========================================
# Continuous Move Until Switch Pressed
# ========================================
def move_upper_until_switch(direction="down", speed=50, timeout=5.0):
    start_time = time()
    print(f"üîß Moving upper motor {direction} until switch pressed...")
    while True:
        if direction == "down":
            upper_motor_down(speed)
        else:
            upper_motor_up(speed)

        if is_upper_switch_pressed():
            print("‚ö†Ô∏è Upper limit switch pressed ‚Äî stopping motor.")
            upper_motor_stop()
            break

        if time() - start_time > timeout:
            print("‚è±Ô∏è Max upper motor move time reached ‚Äî stopping.")
            upper_motor_stop()
            break
        sleep(0.02)

def move_lower_until_switch(direction="down", speed=50, timeout=5.0):
    start_time = time()
    print(f"üîß Moving lower motor {direction} until switch pressed...")
    while True:
        if direction == "down":
            lower_motor_down(speed)
        else:
            lower_motor_up(speed)

        if is_lower_switch_pressed():
            print("‚ö†Ô∏è Lower limit switch pressed ‚Äî stopping motor.")
            lower_motor_stop()
            break

        if time() - start_time > timeout:
            print("‚è±Ô∏è Max lower motor move time reached ‚Äî stopping.")
            lower_motor_stop()
            break
        sleep(0.02)

# ========================================
# Constants
# ========================================
MOTOR_SPEED = 50
MAX_UP_TIME = 5.0
RATIO_THRESHOLD = 0.8

# ========================================
# Phase 1: Initialization
# ========================================
print("üîß Initialization Phase: Moving DOWN to find bottom switches...")
move_upper_until_switch(direction="down", speed=MOTOR_SPEED)
move_lower_until_switch(direction="down", speed=MOTOR_SPEED)
print("üéâ Initialization complete. Baseline posture measurement starting...\n")

# ========================================
# Phase 2: Baseline capture using Mediapipe
# ========================================
mp_pose = mp.solutions.pose
pose = mp_pose.Pose()
cap = cv2.VideoCapture(0)

print("üì∑ Capturing baseline posture... Please sit upright for 3 seconds.")
baseline_dist = None
start_time = time()

while time() - start_time < 3:
    ret, frame = cap.read()
    if not ret:
        continue
    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = pose.process(rgb)

    if results.pose_landmarks:
        lm = results.pose_landmarks.landmark
        nose = lm[mp_pose.PoseLandmark.NOSE]
        left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
        right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]

        shoulder_cx = (left_shoulder.x + right_shoulder.x) / 2
        shoulder_cy = (left_shoulder.y + right_shoulder.y) / 2
        dist = math.sqrt((nose.x - shoulder_cx)**2 + (nose.y - shoulder_cy)**2)

        if baseline_dist is None:
            baseline_dist = dist
        else:
            baseline_dist = (baseline_dist + dist) / 2
    sleep(0.05)

print(f"‚úÖ Baseline captured: {baseline_dist:.4f}\n")

# ========================================
# Phase 3: Real-time posture monitoring
# ========================================
print("üì° Starting real-time posture tracking...")
try:
    while True:
        ret, frame = cap.read()
        if not ret:
            continue
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(rgb)

        if not results.pose_landmarks:
            print("‚ö†Ô∏è Lost landmarks! Stopping motors and waiting...")
            all_stop()
            sleep(0.5)
            continue

        lm = results.pose_landmarks.landmark
        nose = lm[mp_pose.PoseLandmark.NOSE]
        left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
        right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]
        shoulder_cx = (left_shoulder.x + right_shoulder.x) / 2
        shoulder_cy = (left_shoulder.y + right_shoulder.y) / 2

        current_dist = math.sqrt((nose.x - shoulder_cx)**2 + (nose.y - shoulder_cy)**2)
        ratio = current_dist / baseline_dist
        print(f"üìè Current ratio: {ratio:.3f}")

        if ratio < RATIO_THRESHOLD:
            print("üê¢ Turtle neck detected! Adjusting upward...")
            start_up = time()

            while ratio < RATIO_THRESHOLD:
                elapsed = time() - start_up
                if elapsed >= MAX_UP_TIME:
                    print("‚è±Ô∏è Max upward limit reached. Stopping.")
                    break

                upper_motor_up(MOTOR_SPEED)
                lower_motor_up(MOTOR_SPEED)
                sleep(0.1)

                if is_upper_switch_pressed() or is_lower_switch_pressed():
                    print("‚ö†Ô∏è Safety switch triggered. Stopping.")
                    break

                ret, frame = cap.read()
                if not ret:
                    print("‚ö†Ô∏è Frame lost. Stopping.")
                    break
                rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                results = pose.process(rgb)
                if not results.pose_landmarks:
                    print("‚ö†Ô∏è Pose lost mid-correction. Stopping.")
                    break

                lm = results.pose_landmarks.landmark
                nose = lm[mp_pose.PoseLandmark.NOSE]
                left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
                right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]
                shoulder_cx = (left_shoulder.x + right_shoulder.x) / 2
                shoulder_cy = (left_shoulder.y + right_shoulder.y) / 2
                current_dist = math.sqrt((nose.x - shoulder_cx)**2 + (nose.y - shoulder_cy)**2)
                ratio = current_dist / baseline_dist
                print(f"   ‚Üó Adjusting... ratio={ratio:.3f}")

            all_stop()
            print("‚úÖ Correction done or limit reached.\n")

        else:
            all_stop()
            print("üòå Normal posture. Motors stopped.\n")

        sleep(0.2)

except KeyboardInterrupt:
    print("\nüõë Interrupted by user.")

finally:
    cap.release()
    pose.close()
    all_stop()
    pwm1.stop()
    pwm2.stop()
    GPIO.cleanup()
    print("‚úÖ Program terminated safely.")

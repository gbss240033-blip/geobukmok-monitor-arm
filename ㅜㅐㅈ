import cv2
import mediapipe as mp
import RPi.GPIO as GPIO
from time import sleep, time
import math

# ========================================
# GPIO Setup
# ========================================
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# --- Upper Motor ---
Ena1, In1A, In1B = 2, 3, 4
GPIO.setup(Ena1, GPIO.OUT)
GPIO.setup(In1A, GPIO.OUT)
GPIO.setup(In1B, GPIO.OUT)
pwm1 = GPIO.PWM(Ena1, 100)
pwm1.start(0)

# --- Lower Motor ---
EnB, In2A, In2B = 17, 22, 27
GPIO.setup(EnB, GPIO.OUT)
GPIO.setup(In2A, GPIO.OUT)
GPIO.setup(In2B, GPIO.OUT)
pwm2 = GPIO.PWM(EnB, 100)
pwm2.start(0)

# --- Limit Switches (bottom only) ---
SWITCH_UPPER = 5
SWITCH_LOWER = 6
GPIO.setup(SWITCH_UPPER, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SWITCH_LOWER, GPIO.IN, pull_up_down=GPIO.PUD_UP)

def is_upper_switch_pressed():
    """Debounced upper switch read"""
    if GPIO.input(SWITCH_UPPER) == GPIO.LOW:
        sleep(0.02)
        return GPIO.input(SWITCH_UPPER) == GPIO.LOW
    return False

def is_lower_switch_pressed():
    """Debounced lower switch read"""
    if GPIO.input(SWITCH_LOWER) == GPIO.LOW:
        sleep(0.02)
        return GPIO.input(SWITCH_LOWER) == GPIO.LOW
    return False

# ========================================
# Motor Control Functions
# ========================================
def upper_motor_up(speed=50):
    GPIO.output(In1A, GPIO.LOW)
    GPIO.output(In1B, GPIO.HIGH)
    pwm1.ChangeDutyCycle(speed)

def upper_motor_down(speed=50):
    GPIO.output(In1A, GPIO.HIGH)
    GPIO.output(In1B, GPIO.LOW)
    pwm1.ChangeDutyCycle(speed)

def upper_motor_stop():
    GPIO.output(In1A, GPIO.LOW)
    GPIO.output(In1B, GPIO.LOW)
    pwm1.ChangeDutyCycle(0)

def lower_motor_up(speed=50):
    GPIO.output(In2A, GPIO.LOW)
    GPIO.output(In2B, GPIO.HIGH)
    pwm2.ChangeDutyCycle(speed)

def lower_motor_down(speed=50):
    GPIO.output(In2A, GPIO.HIGH)
    GPIO.output(In2B, GPIO.LOW)
    pwm2.ChangeDutyCycle(speed)

def lower_motor_stop():
    GPIO.output(In2A, GPIO.LOW)
    GPIO.output(In2B, GPIO.LOW)
    pwm2.ChangeDutyCycle(0)

def all_stop():
    upper_motor_stop()
    lower_motor_stop()

# ========================================
# Constants
# ========================================
MOTOR_SPEED = 50
MAX_UP_TIME = 5.0
RATIO_THRESHOLD = 0.8

# ========================================
# Phase 1 & 2: Move both motors DOWN until bottom switches pressed
# ========================================
print("üîß Initialization Phase: Moving DOWN to find bottom switches...")

upper_done = False
lower_done = False

try:
    while not (upper_done and lower_done):
        # --- Real-time switch tracking ---
        if is_upper_switch_pressed():
            upper_motor_stop()
            upper_done = True
            print("‚úÖ Upper switch pressed - stopped")
        else:
            if not upper_done:
                upper_motor_down(MOTOR_SPEED)

        if is_lower_switch_pressed():
            lower_motor_stop()
            lower_done = True
            print("‚úÖ Lower switch pressed - stopped")
        else:
            if not lower_done:
                lower_motor_down(MOTOR_SPEED)

        sleep(0.05)

    print("üéâ Initialization complete. Baseline posture measurement starting...\n")

    # ========================================
    # Phase 3: Baseline capture
    # ========================================
    mp_pose = mp.solutions.pose
    pose = mp_pose.Pose()
    cap = cv2.VideoCapture(0)

    print("üì∑ Capturing baseline posture... Please sit upright for 3 seconds.")
    baseline_dist = None
    start_time = time()

    while time() - start_time < 3:
        ret, frame = cap.read()
        if not ret:
            continue
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(rgb)

        if results.pose_landmarks:
            lm = results.pose_landmarks.landmark
            nose = lm[mp_pose.PoseLandmark.NOSE]
            left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
            right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]
            shoulder_cx = (left_shoulder.x + right_shoulder.x) / 2
            shoulder_cy = (left_shoulder.y + right_shoulder.y) / 2
            dist = math.sqrt((nose.x - shoulder_cx)**2 + (nose.y - shoulder_cy)**2)
            baseline_dist = dist if baseline_dist is None else (baseline_dist + dist) / 2
        sleep(0.05)

    print(f"‚úÖ Baseline captured: {baseline_dist:.4f}\n")

    # ========================================
    # Phase 4: Real-time posture monitoring
    # ========================================
    print("üì° Starting real-time posture tracking...")
    while True:
        # --- Always check switches first ---
        if is_upper_switch_pressed() or is_lower_switch_pressed():
            print("‚ö†Ô∏è Safety switch pressed! Stopping all motors.")
            all_stop()
            sleep(0.5)
            continue

        ret, frame = cap.read()
        if not ret:
            continue
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(rgb)

        if not results.pose_landmarks:
            print("‚ö†Ô∏è Lost landmarks! Stopping motors and waiting...")
            all_stop()
            sleep(0.5)
            continue

        lm = results.pose_landmarks.landmark
        nose = lm[mp_pose.PoseLandmark.NOSE]
        left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
        right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]
        shoulder_cx = (left_shoulder.x + right_shoulder.x) / 2
        shoulder_cy = (left_shoulder.y + right_shoulder.y) / 2
        current_dist = math.sqrt((nose.x - shoulder_cx)**2 + (nose.y - shoulder_cy)**2)
        ratio = current_dist / baseline_dist
        print(f"üìè Current ratio: {ratio:.3f}")

        if ratio < RATIO_THRESHOLD:
            print("üê¢ Turtle neck detected! Adjusting upward...")
            start_up = time()

            while ratio < RATIO_THRESHOLD:
                # --- Check switch state continuously ---
                if is_upper_switch_pressed() or is_lower_switch_pressed():
                    print("‚ö†Ô∏è Safety switch triggered during correction.")
                    all_stop()
                    break

                elapsed = time() - start_up
                if elapsed >= MAX_UP_TIME:
                    print("‚è±Ô∏è Max upward limit reached. Stopping.")
                    break

                upper_motor_up(MOTOR_SPEED)
                lower_motor_up(MOTOR_SPEED)
                sleep(0.1)

                ret, frame = cap.read()
                if not ret:
                    print("‚ö†Ô∏è Frame lost. Stopping.")
                    break
                rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                results = pose.process(rgb)
                if not results.pose_landmarks:
                    print("‚ö†Ô∏è Pose lost mid-correction. Stopping.")
                    break

                lm = results.pose_landmarks.landmark
                nose = lm[mp_pose.PoseLandmark.NOSE]
                left_shoulder = lm[mp_pose.PoseLandmark.LEFT_SHOULDER]
                right_shoulder = lm[mp_pose.PoseLandmark.RIGHT_SHOULDER]
                shoulder_cx = (left_shoulder.x + right_shoulder.x) / 2
                shoulder_cy = (left_shoulder.y + right_shoulder.y) / 2
                current_dist = math.sqrt((nose.x - shoulder_cx)**2 + (nose.y - shoulder_cy)**2)
                ratio = current_dist / baseline_dist
                print(f"   ‚Üó Adjusting... ratio={ratio:.3f}")

            all_stop()
            print("‚úÖ Correction done or limit reached.\n")
        else:
            all_stop()
            print("üòå Normal posture. Motors stopped.\n")

        sleep(0.2)

except KeyboardInterrupt:
    print("\nüõë Interrupted by user.")

finally:
    cap.release()
    pose.close()
    all_stop()
    pwm1.stop()
    pwm2.stop()
    GPIO.cleanup()
    print("‚úÖ Program terminated safely.")

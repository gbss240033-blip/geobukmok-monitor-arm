import cv2
import mediapipe as mp
import RPi.GPIO as GPIO
from time import sleep

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
Ena, In1, In2 = 2, 3, 4
GPIO.setup(Ena, GPIO.OUT)
GPIO.setup(In1, GPIO.OUT)
GPIO.setup(In2, GPIO.OUT)

pwm = GPIO.PWM(Ena, 100)  # ì£¼íŒŒìˆ˜ 100Hz
pwm.start(0)

def motor_forward(speed=50):
    GPIO.output(In1, GPIO.LOW)
    GPIO.output(In2, GPIO.HIGH)
    pwm.ChangeDutyCycle(speed)

def motor_stop():
    GPIO.output(In1, GPIO.LOW)
    GPIO.output(In2, GPIO.LOW)
    pwm.ChangeDutyCycle(0)

mp_pose = mp.solutions.pose
mp_drawing = mp.solutions.drawing_utils
pose = mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5)

cap = cv2.VideoCapture(0)

baseline_distance = None
THRESHOLD_RATIO = 0.8     # ì´ ë¹„ìœ¨ë³´ë‹¤ ì‘ìœ¼ë©´ ê±°ë¶ëª©
STABLE_COUNT = 0           # ê±°ë¶ëª©ì´ ì¼ì • ì‹œê°„ ì§€ì†ë  ë•Œë§Œ ì‘ë™
STABLE_THRESHOLD = 5       # í”„ë ˆì„ ê¸°ì¤€ (ì˜ˆ: 5í”„ë ˆì„ ì´ìƒ ê±°ë¶ëª©ì¼ ë•Œ ëª¨í„° ì‘ë™)

print("ğŸ“· ì¹´ë©”ë¼ ì´ˆê¸°í™” ì¤‘... ìì„¸ë¥¼ ë˜‘ë°”ë¡œ í•˜ê³  ê¸°ì¤€ì„ ì¡ì•„ì£¼ì„¸ìš”.")

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("âŒ ì¹´ë©”ë¼ í”„ë ˆì„ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        break

    frame = cv2.flip(frame, 1)
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = pose.process(rgb_frame)

    if results.pose_landmarks:
        landmarks = results.pose_landmarks.landmark

        # ì£¼ìš” ì¢Œí‘œ ì¶”ì¶œ
        nose = landmarks[mp_pose.PoseLandmark.NOSE]
        left_shoulder = landmarks[mp_pose.PoseLandmark.LEFT_SHOULDER]
        right_shoulder = landmarks[mp_pose.PoseLandmark.RIGHT_SHOULDER]

        # ì–´ê¹¨ ì¤‘ì•™ ê³„ì‚°
        shoulder_center_y = (left_shoulder.y + right_shoulder.y) / 2

        # ì–¼êµ´~ì–´ê¹¨ ê±°ë¦¬
        distance = shoulder_center_y - nose.y

        # ì´ˆê¸° ê¸°ì¤€ ì„¤ì •
        if baseline_distance is None:
            baseline_distance = distance
            print("âœ… ê¸°ì¤€ ìì„¸ ì €ì¥ ì™„ë£Œ!")
        else:
            ratio = distance / baseline_distance

            if ratio < THRESHOLD_RATIO:
                STABLE_COUNT += 1
                cv2.putText(frame, "âš ï¸ ê±°ë¶ëª© ê°ì§€!", (50, 60),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
                print(f"âš ï¸ ê±°ë¶ëª© ê°ì§€ ({STABLE_COUNT}/{STABLE_THRESHOLD})")

                # 5í”„ë ˆì„ ì´ìƒ ì§€ì†ë˜ë©´ ëª¨í„° ì‘ë™
                if STABLE_COUNT >= STABLE_THRESHOLD:
                    print("ğŸŸ¢ ëª¨ë‹ˆí„°ì•” ìƒìŠ¹ (ëª¨í„° ì‘ë™)")
                    motor_forward(50)
                    sleep(1)
                    motor_stop()
                    STABLE_COUNT = 0  # ë‹¤ì‹œ ì´ˆê¸°í™”
            else:
                STABLE_COUNT = 0
                cv2.putText(frame, "ğŸ˜Š ì¢‹ì€ ìì„¸!", (50, 60),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                motor_stop()

        mp_drawing.draw_landmarks(frame, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)

    cv2.imshow("Posture Detection", frame)
    if cv2.waitKey(10) & 0xFF == 27:  # ESC í‚¤ ì¢…ë£Œ
        break

cap.release()
motor_stop()
pwm.stop()
GPIO.cleanup()
cv2.destroyAllWindows()
print("í”„ë¡œê·¸ë¨ ì¢…ë£Œ.")
